---
interface Props {
  // Stars Background props
  starDensity?: number;
  allStarsTwinkle?: boolean;
  twinkleProbability?: number;
  minTwinkleSpeed?: number;
  maxTwinkleSpeed?: number;

  // Shooting Stars props
  shootingStarsEnabled?: boolean;
  minSpeed?: number;
  maxSpeed?: number;
  minDelay?: number;
  maxDelay?: number;
  starColor?: string;
  trailColor?: string;
  starWidth?: number;
  starHeight?: number;

  // Background props
  backgroundColor?: string | null;

  // Gravity props
  gravityEnabled?: boolean;
  gravityStrength?: number;
  gravityX?: number | null; // null = center
  gravityY?: number | null; // null = center

  // Black Hole props (for hero orbit only)
  blackHoleEnabled?: boolean;
  blackHoleRotationSpeed?: number;
  blackHoleSpiralStrength?: number;
  blackHoleEventHorizonRadius?: number;

  // Mouse Gravity props
  mouseGravityEnabled?: boolean;
  mouseGravityStrength?: number;
  mouseGravityRadius?: number;
}

const {
  // Stars Background defaults - Optimized for performance
  starDensity = 0.00008, // Reduced from 0.00015 to 0.00008 (47% fewer stars)
  allStarsTwinkle = true,
  twinkleProbability = 0.7,
  minTwinkleSpeed = 0.5,
  maxTwinkleSpeed = 1,

  // Shooting Stars defaults
  shootingStarsEnabled = true,
  minSpeed = 15,
  maxSpeed = 30,
  minDelay = 1200,
  maxDelay = 4200,
  starColor = '#9E00FF',
  trailColor = '#2EB9DF',
  starWidth = 10,
  starHeight = 1,

  // Background defaults
  backgroundColor = '#000',

  // Gravity defaults
  gravityEnabled = true,
  gravityStrength = 8000,
  gravityX = null,
  gravityY = null,

  // Black Hole defaults
  blackHoleEnabled = true,
  blackHoleRotationSpeed = 0.0002, // Slow rotation (radians per frame)
  blackHoleSpiralStrength = 0.00005, // Gradual inward spiral
  blackHoleEventHorizonRadius = 0.3, // 30% of orbit radius

  // Mouse Gravity defaults
  mouseGravityEnabled = true,
  mouseGravityStrength = 0.6,
  mouseGravityRadius = 0.15,
} = Astro.props;
---

<space-background
  data-config={JSON.stringify({
    stars: {
      starDensity,
      allStarsTwinkle,
      twinkleProbability,
      minTwinkleSpeed,
      maxTwinkleSpeed,
    },
    shootingStars: {
      enabled: shootingStarsEnabled,
      minSpeed,
      maxSpeed,
      minDelay,
      maxDelay,
      starColor,
      trailColor,
      starWidth,
      starHeight,
    },
    backgroundColor,
    gravity: {
      enabled: gravityEnabled,
      strength: gravityStrength,
      x: gravityX,
      y: gravityY,
    },
    blackHole: {
      enabled: blackHoleEnabled,
      rotationSpeed: blackHoleRotationSpeed,
      spiralStrength: blackHoleSpiralStrength,
      eventHorizonRadius: blackHoleEventHorizonRadius,
    },
    mouseGravity: {
      enabled: mouseGravityEnabled,
      strength: mouseGravityStrength,
      radius: mouseGravityRadius,
    },
  })}
>
  <canvas class="space-canvas" aria-hidden="true"></canvas>
</space-background>

<script>
  // Interfaces para TypeScript del SpaceBackground optimizado

  interface Star {
    x: number;
    y: number;
    radius: number;
    opacity: number;
    twinkleSpeed: number | null;
    twinklePhase: number;
  }

  interface CachedStarData {
    x: number;
    y: number;
    radius: number;
    opacity: number;
    twinkleSpeed: number | null;
    twinklePhase: number;
    normalizedX: number; // 0-1 para escalado responsive
    normalizedY: number; // 0-1 para escalado responsive
  }

  interface StarFieldCache {
    version: string;
    userId: string;
    created: number;
    lastAccessed: number;
    baseConfig: {
      starDensity: number;
      allStarsTwinkle: boolean;
      twinkleProbability: number;
      minTwinkleSpeed: number;
      maxTwinkleSpeed: number;
    };
    referenceCanvas: { width: number; height: number };
    stars: CachedStarData[];
    checksum: string;
    metadata: {
      generationTime: number;
      starCount: number;
      algorithm: string;
    };
  }

  // Seeded Random Number Generator para patrones determinísticos
  class SeededRandom {
    private m: number = 0x80000000; // 2^31
    private a: number = 1103515245;
    private c: number = 12345;
    private state: number;

    constructor(seed: number) {
      this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
    }

    next(): number {
      this.state = (this.a * this.state + this.c) % this.m;
      return this.state / (this.m - 1);
    }

    nextInRange(min: number, max: number): number {
      return min + this.next() * (max - min);
    }

    nextGaussian(): number {
      // Box-Muller transform para distribución normal
      const u1 = this.next();
      const u2 = this.next();
      return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    }
  }

  // Utilidades de cache y hash
  class StarFieldCacheManager {
    private static readonly CACHE_KEY = 'moura-space-background-v3';
    private static readonly CACHE_VERSION = '3.0.0';
    private static readonly TTL_DAYS = 30;

    static generateUserId(): string {
      const existingId = localStorage.getItem('moura-user-id');
      if (existingId) return existingId;

      // Generar UUID v4 simple
      const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });

      localStorage.setItem('moura-user-id', uuid);
      return uuid;
    }

    static generateChecksum(data: CachedStarData[]): string {
      // Simple hash para validación de integridad
      let hash = 0;
      const str = JSON.stringify(data);
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return hash.toString(36);
    }

    static saveCache(cache: StarFieldCache): boolean {
      try {
        cache.lastAccessed = Date.now();
        cache.checksum = this.generateChecksum(cache.stars);
        localStorage.setItem(this.CACHE_KEY, JSON.stringify(cache));
        return true;
      } catch (error) {
        console.warn('Failed to save star field cache:', error);
        return false;
      }
    }

    static loadCache(): StarFieldCache | null {
      try {
        const cached = localStorage.getItem(this.CACHE_KEY);
        if (!cached) return null;

        const cache: StarFieldCache = JSON.parse(cached);

        // Validaciones de integridad
        if (cache.version !== this.CACHE_VERSION) {
          this.clearCache();
          return null;
        }

        // Verificar TTL
        const age = Date.now() - cache.created;
        const maxAge = this.TTL_DAYS * 24 * 60 * 60 * 1000;
        if (age > maxAge) {
          this.clearCache();
          return null;
        }

        // Verificar checksum
        const expectedChecksum = this.generateChecksum(cache.stars);
        if (cache.checksum !== expectedChecksum) {
          console.warn('Star field cache corrupted, regenerating');
          this.clearCache();
          return null;
        }

        // Actualizar último acceso
        cache.lastAccessed = Date.now();
        this.saveCache(cache);

        return cache;
      } catch (error) {
        console.warn('Failed to load star field cache:', error);
        this.clearCache();
        return null;
      }
    }

    static clearCache(): void {
      localStorage.removeItem(this.CACHE_KEY);
    }

    static isCacheValidForCanvas(cache: StarFieldCache, width: number, height: number): boolean {
      const tolerance = 0.1; // 10% tolerance
      const widthDiff = Math.abs(cache.referenceCanvas.width - width) / width;
      const heightDiff = Math.abs(cache.referenceCanvas.height - height) / height;

      return widthDiff <= tolerance && heightDiff <= tolerance;
    }
  }

  interface ShootingStar {
    x: number;
    y: number;
    angle: number;
    speed: number;
    length: number;
    opacity: number;
    active: boolean;
    trail: Array<{ x: number; y: number; opacity: number }>;
    maxTrailLength: number;
  }

  interface Config {
    stars: {
      starDensity: number;
      allStarsTwinkle: boolean;
      twinkleProbability: number;
      minTwinkleSpeed: number;
      maxTwinkleSpeed: number;
    };
    shootingStars: {
      enabled: boolean;
      minSpeed: number;
      maxSpeed: number;
      minDelay: number;
      maxDelay: number;
      starColor: string;
      trailColor: string;
      starWidth: number;
      starHeight: number;
    };
    backgroundColor: string | null;
    gravity: {
      enabled: boolean;
      strength: number;
      x: number | null;
      y: number | null;
    };
    blackHole: {
      enabled: boolean;
      rotationSpeed: number;
      spiralStrength: number;
      eventHorizonRadius: number;
    };
    mouseGravity: {
      enabled: boolean;
      strength: number;
      radius: number;
    };
  }

  class SpaceBackground extends HTMLElement {
    private config: Config;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D | null;
    private stars: Star[] = [];
    private shootingStars: ShootingStar[] = [];
    private shootingStarPool: ShootingStar[] = [];
    private animationId: number | null = null;
    private resizeTimeout: number | null = null;
    private lastTime: number = 0;
    private nextShootingStarTime: number = 0;
    private width: number = 0;
    private height: number = 0;
    private dpr: number = 1;
    // Performance optimization - frame counters for throttling expensive effects
    private frameCount: number = 0;
    private gravitationalEffectsInterval: number = 2; // Apply gravitational effects every N frames
    private shootingStarColors: { r: number; g: number; b: number };
    private trailColors: { r: number; g: number; b: number };
    private orbitContainer: Element | null = null;
    private orbitRect: DOMRect | null = null;
    private mouseX: number = -1000; // Start off-screen
    private mouseY: number = -1000;
    private mouseGravityStrength: number;
    private mouseGravityRadius: number;
    // Mobile viewport optimization
    private lastWidth: number = 0;
    private lastHeight: number = 0;
    private isMobile: boolean = false;
    private stableHeight: number = 0;
    // Performance optimization - limit active shooting stars to prevent lag issues
    private readonly maxActiveShootingStars: number = 2;
    // Black hole effect tracking
    private blackHoleRotationTime: number = 0;
    // Logo effect states
    private explosionActive: boolean = false;
    private explosionStartTime: number = 0;
    private explosionDuration: number = 2000; // 2 seconds
    private logoBlackHoleActive: boolean = false;
    private logoBlackHoleStartTime: number = 0;
    private logoBlackHoleDuration: number = 4000; // 4 seconds
    private logoBlackHoleCenter: { x: number; y: number } = { x: 0, y: 0 };
    private originalStars: Star[] = [];

    constructor() {
      super();
      this.canvas = this.querySelector('.space-canvas') as HTMLCanvasElement;
      this.ctx = this.canvas?.getContext('2d', { alpha: false });

      try {
        this.config = JSON.parse(this.dataset.config || '{}');
      } catch (e) {
        console.warn('Failed to parse space background config:', e);
        this.config = {
          stars: {
            starDensity: 0.00015,
            allStarsTwinkle: true,
            twinkleProbability: 0.7,
            minTwinkleSpeed: 0.5,
            maxTwinkleSpeed: 1,
          },
          shootingStars: {
            enabled: true,
            minSpeed: 10,
            maxSpeed: 30,
            minDelay: 1200,
            maxDelay: 4200,
            starColor: '#9E00FF',
            trailColor: '#2EB9DF',
            starWidth: 10,
            starHeight: 1,
          },
          backgroundColor: '#000',
          gravity: {
            enabled: true,
            strength: 8000,
            x: null,
            y: null,
          },
          blackHole: {
            enabled: true,
            rotationSpeed: 0.0008,
            spiralStrength: 0.0002,
            eventHorizonRadius: 0.3,
          },
          mouseGravity: {
            enabled: true,
            strength: 0.6,
            radius: 0.15,
          },
        };
      }

      // Set mouse gravity values from config
      this.mouseGravityStrength = this.config.mouseGravity.strength;
      this.mouseGravityRadius = this.config.mouseGravity.radius;

      // Parse colors once
      this.shootingStarColors = this.hexToRgb(this.config.shootingStars.starColor);
      this.trailColors = this.hexToRgb(this.config.shootingStars.trailColor);

      this.setupBackground();
    }

    private hexToRgb(hex: string): { r: number; g: number; b: number } {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : { r: 255, g: 255, b: 255 };
    }

    private setupBackground(): void {
      if (!this.canvas || !this.ctx) return;

      // Reset orbit references to ensure clean state
      this.orbitContainer = null;
      this.orbitRect = null;

      // Detect mobile device
      this.isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) || window.innerWidth <= 768;

      // Set canvas styles
      this.canvas.style.position = 'absolute';
      this.canvas.style.inset = '0';
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';

      // Find orbit container for gravity
      this.findOrbitContainer();

      // Add mouse tracking
      this.setupMouseTracking();

      // Add logo effect event listeners
      this.setupLogoEffectListeners();

      // Skip animations if user prefers reduced motion
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        this.setupCanvas();
        this.initializeStars();
        this.renderStatic();
        return;
      }

      // Setup and start
      this.setupCanvas();
      this.initializeStars();
      this.initializeShootingStarPool();

      // Schedule first shooting star
      if (this.config.shootingStars.enabled) {
        this.scheduleNextShootingStar();
      }

      // Add resize listener with mobile optimization
      if (this.isMobile) {
        // Use visual viewport API if available for better mobile handling
        if ('visualViewport' in window && window.visualViewport) {
          interface VisualViewport extends EventTarget {
            addEventListener(type: string, listener: EventListener): void;
          }
          const visualViewport = window.visualViewport as VisualViewport;
          visualViewport.addEventListener('resize', this.handleMobileViewportChange.bind(this));
        } else {
          window.addEventListener('resize', this.handleMobileResize.bind(this));
        }
      } else {
        window.addEventListener('resize', this.handleResize.bind(this));
      }

      // Start animation
      this.lastTime = performance.now();
      this.animateFrame();
    }

    private setupMouseTracking(): void {
      // Only set up mouse tracking if mouse gravity is enabled
      if (this.config.mouseGravity.enabled) {
        // Add event listeners
        window.addEventListener('mousemove', this.handleMouseMove);
        this.canvas.addEventListener('mouseleave', this.handleMouseLeave);
      }
    }

    private setupLogoEffectListeners(): void {
      // Listen for star field distortion (explosion effect)
      window.addEventListener('starFieldDistort', this.handleStarFieldDistort);
      
      // Listen for black hole effect from logo
      window.addEventListener('blackHoleActivated', this.handleBlackHoleActivated);
    }

    private setupCanvas(): void {
      const rect = this.canvas.getBoundingClientRect();
      this.width = rect.width;
      this.height = rect.height;
      this.dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2 for performance

      this.canvas.width = this.width * this.dpr;
      this.canvas.height = this.height * this.dpr;

      if (this.ctx) {
        this.ctx.scale(this.dpr, this.dpr);
        // Set background once
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.width, this.height);
      }
    }

    private initializeStars(): void {
      const startTime = performance.now();

      // Intentar cargar desde cache primero
      const cachedData = StarFieldCacheManager.loadCache();

      if (
        cachedData &&
        this.isConfigCompatible(cachedData.baseConfig) &&
        StarFieldCacheManager.isCacheValidForCanvas(cachedData, this.width, this.height)
      ) {
        console.log(`🌟 Loading stars from cache (${cachedData.stars.length} stars)`);
        this.loadStarsFromCache(cachedData);

        const loadTime = performance.now() - startTime;
        console.log(`⚡ Stars loaded in ${loadTime.toFixed(2)}ms (cached)`);
        return;
      }

      // Generar nuevo patrón determinístico
      console.log('🎲 Generating new deterministic star pattern');
      this.generateDeterministicStars();

      // Guardar en cache
      this.saveTCache();

      const generationTime = performance.now() - startTime;
      console.log(`✨ Stars generated in ${generationTime.toFixed(2)}ms (new pattern)`);
    }

    private isConfigCompatible(cachedConfig: StarFieldCache['baseConfig']): boolean {
      const current = this.config.stars;
      return (
        cachedConfig.starDensity === current.starDensity &&
        cachedConfig.allStarsTwinkle === current.allStarsTwinkle &&
        cachedConfig.twinkleProbability === current.twinkleProbability &&
        Math.abs(cachedConfig.minTwinkleSpeed - current.minTwinkleSpeed) < 0.01 &&
        Math.abs(cachedConfig.maxTwinkleSpeed - current.maxTwinkleSpeed) < 0.01
      );
    }

    private loadStarsFromCache(cache: StarFieldCache): void {
      // Convertir coordenadas normalizadas a posiciones actuales
      this.stars = cache.stars.map((cachedStar) => ({
        x: cachedStar.normalizedX * this.width,
        y: cachedStar.normalizedY * this.height,
        radius: cachedStar.radius,
        opacity: cachedStar.opacity,
        twinkleSpeed: cachedStar.twinkleSpeed,
        twinklePhase: cachedStar.twinklePhase,
      }));
    }

    private generateDeterministicStars(): void {
      const { starDensity, allStarsTwinkle, twinkleProbability, minTwinkleSpeed, maxTwinkleSpeed } =
        this.config.stars;

      // Crear semilla única basada en user ID + configuración
      const userId = StarFieldCacheManager.generateUserId();
      const configSeed = this.generateConfigSeed();
      const masterSeed = this.hashString(userId + configSeed);

      const rng = new SeededRandom(masterSeed);

      const area = this.width * this.height;
      // Dynamic star limit based on device capabilities
      const getMaxStars = () => {
        const isMobile = window.innerWidth <= 768;
        const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4;
        
        if (isMobile || isLowEnd) return 800;  // Reduced for mobile/low-end
        if (area > 3000000) return 1500;      // Large screens: cap at 1500
        return 1200;                          // Default: cap at 1200
      };

      const numStars = Math.min(
        Math.floor(area * starDensity),
        getMaxStars()
      );

      this.stars = Array.from({ length: numStars }, () => {
        const shouldTwinkle = allStarsTwinkle || rng.next() < twinkleProbability;
        return {
          x: rng.next() * this.width,
          y: rng.next() * this.height,
          radius: rng.nextInRange(0.5, 0.55),
          opacity: rng.nextInRange(0.5, 1.0),
          twinkleSpeed: shouldTwinkle ? rng.nextInRange(minTwinkleSpeed, maxTwinkleSpeed) : null,
          twinklePhase: rng.next() * Math.PI * 2,
        };
      });
    }

    private generateConfigSeed(): string {
      const config = this.config.stars;
      return `${config.starDensity}-${config.allStarsTwinkle}-${config.twinkleProbability}-${config.minTwinkleSpeed}-${config.maxTwinkleSpeed}`;
    }

    private hashString(str: string): number {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return Math.abs(hash);
    }

    private saveTCache(): void {
      const userId = StarFieldCacheManager.generateUserId();

      // Convertir estrellas a formato con coordenadas normalizadas
      const normalizedStars: CachedStarData[] = this.stars.map((star) => ({
        x: star.x,
        y: star.y,
        radius: star.radius,
        opacity: star.opacity,
        twinkleSpeed: star.twinkleSpeed,
        twinklePhase: star.twinklePhase,
        normalizedX: star.x / this.width,
        normalizedY: star.y / this.height,
      }));

      const cache: StarFieldCache = {
        version: '3.0.0',
        userId,
        created: Date.now(),
        lastAccessed: Date.now(),
        baseConfig: {
          starDensity: this.config.stars.starDensity,
          allStarsTwinkle: this.config.stars.allStarsTwinkle,
          twinkleProbability: this.config.stars.twinkleProbability,
          minTwinkleSpeed: this.config.stars.minTwinkleSpeed,
          maxTwinkleSpeed: this.config.stars.maxTwinkleSpeed,
        },
        referenceCanvas: {
          width: this.width,
          height: this.height,
        },
        stars: normalizedStars,
        checksum: '', // Will be generated by saveCache
        metadata: {
          generationTime: performance.now(),
          starCount: this.stars.length,
          algorithm: 'SeededRandom-v3.0.0',
        },
      };

      StarFieldCacheManager.saveCache(cache);
    }

    private initializeShootingStarPool(): void {
      // Pre-create shooting stars for object pooling - reduced pool size for better performance
      const poolSize = 3; // Smaller pool since we only need max 2 active
      for (let i = 0; i < poolSize; i++) {
        this.shootingStarPool.push({
          x: 0,
          y: 0,
          angle: 0,
          speed: 0,
          length: this.config.shootingStars.starWidth,
          opacity: 1,
          active: false,
          trail: [],
          maxTrailLength: 10,
        });
      }
    }

    private getShootingStar(): ShootingStar | null {
      // Get from pool or create new one - strict limit to prevent lag
      let star = this.shootingStarPool.find((s) => !s.active);
      if (!star && this.shootingStarPool.length < 3) { // Reduced from 10 to 3
        star = {
          x: 0,
          y: 0,
          angle: 0,
          speed: 0,
          length: this.config.shootingStars.starWidth,
          opacity: 1,
          active: false,
          trail: [],
          maxTrailLength: 15, // Reduced trail length for better performance
        };
        this.shootingStarPool.push(star);
      }
      return star || null;
    }

    private scheduleNextShootingStar(): void {
      const { minDelay, maxDelay } = this.config.shootingStars;
      const delay = Math.random() * (maxDelay - minDelay) + minDelay;
      this.nextShootingStarTime = performance.now() + delay;
    }

    private createShootingStar(): void {
      // Double-check we haven't exceeded the limit before creating
      if (this.shootingStars.length >= this.maxActiveShootingStars) {
        return;
      }
      
      const star = this.getShootingStar();
      if (!star) return;

      const { minSpeed, maxSpeed } = this.config.shootingStars;
      const side = Math.floor(Math.random() * 4);
      const offset = Math.random();

      // Set starting position based on side
      switch (side) {
        case 0: // Top
          star.x = offset * this.width;
          star.y = -50;
          star.angle = Math.PI / 4 + (Math.random() * Math.PI) / 2;
          break;
        case 1: // Right
          star.x = this.width + 50;
          star.y = offset * this.height;
          star.angle = (3 * Math.PI) / 4 + (Math.random() * Math.PI) / 2;
          break;
        case 2: // Bottom
          star.x = offset * this.width;
          star.y = this.height + 50;
          star.angle = (5 * Math.PI) / 4 + (Math.random() * Math.PI) / 2;
          break;
        case 3: // Left
          star.x = -50;
          star.y = offset * this.height;
          star.angle = (7 * Math.PI) / 4 + (Math.random() * Math.PI) / 2;
          break;
      }

      star.speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
      star.opacity = 1;
      star.active = true;
      star.length = this.config.shootingStars.starWidth;
      star.trail = []; // Reset trail for new shooting star

      this.shootingStars.push(star);
    }

    private findOrbitContainer(): void {
      // Try specific selectors for actual orbit container elements
      // Be more specific to avoid false positives
      this.orbitContainer =
        document.querySelector('.orbit-container') ||
        document.querySelector('#orbit-container') ||
        document.querySelector('[data-orbit-container]') ||
        document.querySelector('.hero-orbit-container');

      // Reset orbitRect if no container found
      if (this.orbitContainer) {
        this.updateOrbitRect();
        // Debug: Check if we actually found a valid orbit element
        const rect = this.orbitContainer.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn('Found orbit container but it has no dimensions, disabling gravity');
          this.orbitContainer = null;
          this.orbitRect = null;
        }
      } else {
        this.orbitRect = null;
      }
    }

    private updateOrbitRect(): void {
      if (this.orbitContainer) {
        this.orbitRect = this.orbitContainer.getBoundingClientRect();
      }
    }

    private getGravityCoordinates(): { x: number; y: number; width: number; height: number } {
      // Update orbit rect in case element moved
      this.updateOrbitRect();

      if (this.orbitRect) {
        // Use orbit container center and dimensions
        return {
          x: this.orbitRect.left + this.orbitRect.width / 2,
          y: this.orbitRect.top + this.orbitRect.height / 2,
          width: this.orbitRect.width,
          height: this.orbitRect.height,
        };
      }

      // If no orbit element, return center of screen (but this should not be used)
      // The calling methods should check for orbitContainer existence first
      return {
        x: this.width / 2,
        y: this.height / 2,
        width: 0,
        height: 0,
      };
    }

    private applyGravity(star: ShootingStar, deltaTime: number): void {
      // Only apply gravity if enabled AND orbit element exists
      if (!this.config.gravity.enabled || !this.orbitContainer) return;

      const gravity = this.getGravityCoordinates();

      // Calculate distance to gravity center
      const dx = gravity.x - star.x;
      const dy = gravity.y - star.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Avoid division by zero and too strong forces when very close
      if (distance < Math.min(gravity.width, gravity.height) / 4) return;

      // Calculate gravitational force - stronger within orbit area
      const orbitRadius = Math.max(gravity.width, gravity.height) / 2;
      const strengthMultiplier = distance < orbitRadius ? 2 : 1;
      const force = (this.config.gravity.strength * strengthMultiplier) / (distance * distance);
      const normalizedDelta = deltaTime / 16.67; // Normalize to 60fps

      // Apply force to velocity components
      const forceX = (dx / distance) * force * normalizedDelta;
      const forceY = (dy / distance) * force * normalizedDelta;

      // Get current velocity components
      const currentVelX = Math.cos(star.angle) * star.speed;
      const currentVelY = Math.sin(star.angle) * star.speed;

      // Update velocity
      const newVelX = currentVelX + forceX;
      const newVelY = currentVelY + forceY;

      // Update star angle and speed
      star.angle = Math.atan2(newVelY, newVelX);
      star.speed = Math.sqrt(newVelX * newVelX + newVelY * newVelY);
    }

    private applyMultipleGravitationalLensing(star: Star): { x: number; y: number } {
      let currentPosition = { x: star.x, y: star.y };

      // Apply logo black hole effect if active - this should OVERRIDE all other effects
      if (this.logoBlackHoleActive) {
        currentPosition = this.applyLogoBlackHoleEffect(star, currentPosition);
        // Return early - black hole effect should dominate
        return currentPosition;
      }

      // Apply normal gravity effects first (orbit gravity and mouse gravity)
      // Only apply orbit gravity lensing if orbit element exists and has valid dimensions
      if (this.orbitContainer && this.orbitRect && this.config.gravity.enabled) {
        // Double check that the orbit is actually visible
        const rect = this.orbitContainer.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          const gravityCoords = this.getGravityCoordinates();

          // Apply regular gravitational lensing first
          currentPosition = this.applySingleGravitationalLensing(
            star,
            {
              x: gravityCoords.x,
              y: gravityCoords.y,
            },
            2.0,
            0.3
          );

          // Apply black hole effects if enabled
          if (this.config.blackHole.enabled) {
            currentPosition = this.applyBlackHoleEffects(
              {
                x: currentPosition.x,
                y: currentPosition.y,
                radius: star.radius,
                opacity: star.opacity,
                twinkleSpeed: star.twinkleSpeed,
                twinklePhase: star.twinklePhase,
              },
              {
                x: gravityCoords.x,
                y: gravityCoords.y,
              },
              gravityCoords.width
            );
          }
        }
      }

      // Apply mouse gravity if enabled and mouse is on screen
      if (
        this.config.mouseGravity.enabled &&
        this.mouseX > 0 &&
        this.mouseY > 0 &&
        this.mouseX < this.width &&
        this.mouseY < this.height
      ) {
        const mouseLensed = this.applySingleGravitationalLensing(
          {
            x: currentPosition.x,
            y: currentPosition.y,
            radius: star.radius,
            opacity: star.opacity,
            twinkleSpeed: star.twinkleSpeed,
            twinklePhase: star.twinklePhase,
          },
          {
            x: this.mouseX,
            y: this.mouseY,
          },
          this.mouseGravityStrength,
          this.mouseGravityRadius
        );

        currentPosition = mouseLensed;
      }

      // Apply explosion effect AFTER all gravity effects (additive, not replacing)
      if (this.explosionActive) {
        currentPosition = this.applyExplosionEffect(star, currentPosition);
      }

      return currentPosition;
    }

    private applyLogoBlackHoleEffect(star: Star, currentPosition: { x: number; y: number }): { x: number; y: number } {
      const currentTime = performance.now();
      const elapsed = currentTime - this.logoBlackHoleStartTime;
      const progress = Math.min(elapsed / this.logoBlackHoleDuration, 1);
      
      // Calculate distance to black hole center
      const dx = this.logoBlackHoleCenter.x - currentPosition.x;
      const dy = this.logoBlackHoleCenter.y - currentPosition.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Create distance-based effect intensity (closer stars are affected more)
      const maxDistance = Math.max(this.width, this.height);
      const distanceRatio = Math.min(distance / maxDistance, 1);
      
      // More dramatic distance-based delay - closer stars affected much earlier
      const distanceDelayFactor = 1 - distanceRatio * 0.6; // Increased delay differential
      const adjustedProgress = Math.max(0, (progress - (1 - distanceDelayFactor) * 0.6) / distanceDelayFactor);
      
      // More dramatic effect curves
      let effectStrength = 0;
      if (progress < 0.6) {
        // Intense sucking phase with exponential acceleration
        const suckProgress = progress / 0.6;
        effectStrength = 1 - Math.pow(1 - suckProgress, 3); // Steeper curve for more dramatic effect
      } else {
        // Dramatic recovery phase
        const fadeProgress = (progress - 0.6) / 0.4;
        const smoothFade = 1 - Math.pow(fadeProgress, 2.5); // More pronounced fade
        effectStrength = smoothFade;
      }
      
      // Apply distance-based delay to the overall effect strength
      const delayedEffectStrength = effectStrength * Math.max(0, Math.min(1, adjustedProgress));
      
      // Much more dramatic suction strength based on distance
      let suckStrength = 0;
      if (delayedEffectStrength > 0) {
        const baseStrength = delayedEffectStrength * 1.2; // Increased base strength
        const distanceMultiplier = 1 + (1 - distanceRatio) * 1.5; // Much stronger pull for closer stars
        suckStrength = baseStrength * distanceMultiplier;
      }
      
      // Apply the pull effect with natural falloff
      const pullX = dx * suckStrength;
      const pullY = dy * suckStrength;
      
      // More intense swirl that creates visible spirals
      const angle = Math.atan2(dy, dx);
      const swirlIntensity = Math.sin(adjustedProgress * Math.PI) * (3 + Math.sin(distance * 0.008) * 1.2) * delayedEffectStrength;
      
      // Enhanced swirl with multiple layers of rotation
      const swirlSpeedVariation = 1 + Math.sin(star.x * 0.001 + star.y * 0.001) * 0.5;
      const primarySwirlSpeed = elapsed * 0.01 * swirlSpeedVariation;
      const secondarySwirlSpeed = elapsed * 0.004 * (2 - swirlSpeedVariation);
      
      // Multi-layered spiral effect
      const baseRadius = Math.min(distance * 0.4, 200);
      const radiusVariation = 1 + Math.sin(star.x * 0.002 + star.y * 0.002) * 0.6;
      const primarySwirlRadius = baseRadius * radiusVariation;
      const secondarySwirlRadius = baseRadius * 0.5 * radiusVariation;
      
      // Primary spiral
      const primarySwirlX = Math.cos(angle + primarySwirlSpeed) * primarySwirlRadius * 0.5 * swirlIntensity * (1 - distanceRatio * 0.3);
      const primarySwirlY = Math.sin(angle + primarySwirlSpeed) * primarySwirlRadius * 0.5 * swirlIntensity * (1 - distanceRatio * 0.3);
      
      // Secondary counter-spiral for more complex motion
      const secondarySwirlX = Math.cos(angle - secondarySwirlSpeed) * secondarySwirlRadius * 0.3 * swirlIntensity * (1 - distanceRatio * 0.4);
      const secondarySwirlY = Math.sin(angle - secondarySwirlSpeed) * secondarySwirlRadius * 0.3 * swirlIntensity * (1 - distanceRatio * 0.4);
      
      // Combined swirl effect
      const swirlX = primarySwirlX + secondarySwirlX;
      const swirlY = primarySwirlY + secondarySwirlY;
      
      // More dramatic chaos that creates visible disturbances
      const chaosRadius = 300; // Increased radius
      let chaosX = 0;
      let chaosY = 0;
      
      if (distance < chaosRadius && delayedEffectStrength > 0) {
        const chaosStrength = (chaosRadius - distance) / chaosRadius * delayedEffectStrength * 1.5; // Increased strength
        
        // Multi-frequency chaos for more complex patterns
        const starSeed = star.x * 0.01 + star.y * 0.01;
        const chaos1 = Math.sin(elapsed * 0.03 + starSeed * 1.5) * 45 * chaosStrength;
        const chaos2 = Math.cos(elapsed * 0.035 + starSeed * 2.0) * 35 * chaosStrength;
        const chaos3 = Math.sin(elapsed * 0.04 + starSeed * 0.8) * 25 * chaosStrength;
        const chaos4 = Math.cos(elapsed * 0.025 + starSeed * 2.5) * 20 * chaosStrength;
        
        chaosX = chaos1 + chaos3 + chaos4 * 0.6;
        chaosY = chaos2 + chaos1 * 0.5 + chaos4 * 0.4;
      }
      
      // Enhanced turbulence with wider range
      let turbulenceX = 0;
      let turbulenceY = 0;
      
      if (distance < 150 && delayedEffectStrength > 0) {
        const turbulenceStrength = (150 - distance) / 150 * delayedEffectStrength * 1.3; // Increased range and strength
        const turbulenceSeed = star.x * 0.005 + star.y * 0.005;
        
        // Multiple turbulence frequencies for richer motion
        const turb1 = Math.sin(elapsed * 0.05 + turbulenceSeed * 3) * 60 * turbulenceStrength;
        const turb2 = Math.cos(elapsed * 0.045 + turbulenceSeed * 2.5) * 50 * turbulenceStrength;
        const turb3 = Math.sin(elapsed * 0.055 + turbulenceSeed * 4) * 30 * turbulenceStrength;
        
        turbulenceX = turb1 + turb3 * 0.7;
        turbulenceY = turb2 + turb1 * 0.6;
      }
      
      // Add gravitational wave effect for stars at medium distance
      let waveX = 0;
      let waveY = 0;
      
      if (distance > 100 && distance < 400 && delayedEffectStrength > 0) {
        const waveStrength = Math.sin((distance - 100) / 300 * Math.PI) * delayedEffectStrength * 0.8;
        const waveFreq = elapsed * 0.008 + distance * 0.002;
        
        waveX = Math.sin(waveFreq) * 20 * waveStrength;
        waveY = Math.cos(waveFreq * 1.3) * 15 * waveStrength;
      }
      
      // Apply all effects with dramatic variation
      const finalX = currentPosition.x + pullX + swirlX + chaosX + turbulenceX + waveX;
      const finalY = currentPosition.y + pullY + swirlY + chaosY + turbulenceY + waveY;
      
      return {
        x: finalX,
        y: finalY
      };
    }

    private applyExplosionEffect(star: Star, currentPosition: { x: number; y: number }): { x: number; y: number } {
      const currentTime = performance.now();
      const elapsed = currentTime - this.explosionStartTime;
      const progress = elapsed / this.explosionDuration;
      
      // Create a wave effect that expands outward from the center
      const centerX = this.width / 2;
      const centerY = this.height / 2;
      
      const dx = currentPosition.x - centerX;
      const dy = currentPosition.y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Create multiple waves with different frequencies
      const waveRadius = progress * Math.max(this.width, this.height) * 2;
      const waveWidth = 150; // Width of the wave
      
      // Primary wave
      const wave1 = Math.sin((waveRadius - distance) * 0.02) * Math.exp(-Math.abs(waveRadius - distance) / waveWidth);
      // Secondary wave with different frequency
      const wave2 = Math.sin((waveRadius - distance) * 0.05) * Math.exp(-Math.abs(waveRadius - distance) / (waveWidth * 0.7));
      
      const combinedWave = wave1 + wave2 * 0.5;
      
      // Significantly increase distortion strength
      const distortionStrength = combinedWave * 80 * (1 - progress * 0.7); // Much stronger effect
      const angle = Math.atan2(dy, dx);
      
      // Add chaotic noise for more dramatic effect
      const noise = (Math.sin(distance * 0.05 + elapsed * 0.008) + Math.cos(distance * 0.03 + elapsed * 0.012)) * 0.8;
      const finalDistortion = distortionStrength * (1 + noise * 0.6);
      
      return {
        x: currentPosition.x + Math.cos(angle) * finalDistortion,
        y: currentPosition.y + Math.sin(angle) * finalDistortion
      };
    }

    private applyBlackHoleEffects(
      star: Star,
      blackHoleCenter: { x: number; y: number },
      orbitWidth: number
    ): { x: number; y: number } {
      const dx = star.x - blackHoleCenter.x;
      const dy = star.y - blackHoleCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Define black hole influence radius (based on orbit size)
      const maxBlackHoleRadius = (orbitWidth / 2) * 0.8; // 80% of orbit radius
      if (distance > maxBlackHoleRadius) {
        return { x: star.x, y: star.y };
      }

      // Calculate influence strength (stronger closer to center)
      const influenceStrength = 1 - distance / maxBlackHoleRadius;
      const eventHorizonRadius = maxBlackHoleRadius * this.config.blackHole.eventHorizonRadius;

      // 1. Rotational Effect (left to right / clockwise)
      const currentAngle = Math.atan2(dy, dx);
      const rotationAmount =
        this.config.blackHole.rotationSpeed * influenceStrength * this.blackHoleRotationTime;
      const newAngle = currentAngle + rotationAmount;

      // 2. Spiral Inward Effect
      let spiralDistance = distance;
      if (distance > eventHorizonRadius) {
        const spiralAmount = this.config.blackHole.spiralStrength * influenceStrength;
        spiralDistance = Math.max(distance - spiralAmount, eventHorizonRadius);
      }

      // 3. Event Horizon Effect - stars get trapped at the event horizon
      const finalDistance = Math.max(spiralDistance, eventHorizonRadius);

      // Calculate new position
      const newX = blackHoleCenter.x + Math.cos(newAngle) * finalDistance;
      const newY = blackHoleCenter.y + Math.sin(newAngle) * finalDistance;

      return { x: newX, y: newY };
    }

    private applySingleGravitationalLensing(
      star: Star,
      gravityCenter: { x: number; y: number },
      strength: number,
      maxRadiusRatio: number
    ): { x: number; y: number } {
      const dx = star.x - gravityCenter.x;
      const dy = star.y - gravityCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Only apply lensing within a certain radius
      const maxLensingRadius = Math.min(this.width, this.height) * maxRadiusRatio;
      if (distance > maxLensingRadius) {
        return { x: star.x, y: star.y };
      }

      // Calculate lensing strength
      const lensingStrength = (1 - distance / maxLensingRadius) * strength;

      // Apply distortion
      const angle = Math.atan2(dy, dx);
      const distortedDistance = distance * (1 + lensingStrength);

      // Add tangential distortion to create swirl
      const tangentialDistortion = lensingStrength * 0.5;
      const newAngle = angle + tangentialDistortion;

      return {
        x: gravityCenter.x + Math.cos(newAngle) * distortedDistance,
        y: gravityCenter.y + Math.sin(newAngle) * distortedDistance,
      };
    }

    private updateShootingStars(deltaTime: number): void {
      const padding = 100;

      for (let i = this.shootingStars.length - 1; i >= 0; i--) {
        const star = this.shootingStars[i];

        // Apply gravity first
        this.applyGravity(star, deltaTime);

        // Add current position to trail history
        star.trail.push({
          x: star.x,
          y: star.y,
          opacity: 1,
        });

        // Limit trail length for performance
        if (star.trail.length > star.maxTrailLength) {
          star.trail.shift();
        }

        // Update position
        const distance = (star.speed * deltaTime) / 16.67; // Normalize to 60fps
        star.x += Math.cos(star.angle) * distance;
        star.y += Math.sin(star.angle) * distance;

        // Update trail opacities (fade older points)
        star.trail.forEach((point, index) => {
          point.opacity = index / star.trail.length;
        });

        // Check if off screen
        if (
          star.x < -padding ||
          star.x > this.width + padding ||
          star.y < -padding ||
          star.y > this.height + padding
        ) {
          star.active = false;
          this.shootingStars.splice(i, 1);
        }
      }

      // Create new shooting star if it's time and we haven't reached the limit
      if (this.config.shootingStars.enabled && performance.now() >= this.nextShootingStarTime) {
        // Only create if we're below the strict limit
        if (this.shootingStars.length < this.maxActiveShootingStars) {
          this.createShootingStar();
        }
        // Always reschedule the next shooting star regardless of whether we created one
        // This prevents getting stuck when at the limit
        this.scheduleNextShootingStar();
      }
    }

    private render(): void {
      if (!this.ctx) return;

      const ctx = this.ctx; // Store reference to avoid null checks

      // Clear canvas - only if background color is set
      if (this.config.backgroundColor) {
        ctx.fillStyle = this.config.backgroundColor;
        ctx.fillRect(0, 0, this.width, this.height);
      } else {
        ctx.clearRect(0, 0, this.width, this.height);
      }

      // Draw stars with gravitational lensing and black hole effects
      const time = performance.now() * 0.001;
      
      // Viewport culling - only render visible stars (performance optimization)
      const padding = 50; // Small padding for smooth transitions
      const visibleStars = this.stars.filter(star => 
        star.x >= -padding && star.x <= this.width + padding &&
        star.y >= -padding && star.y <= this.height + padding
      );

      // Increment frame counter for performance throttling
      this.frameCount++;
      
      // Adaptive throttling based on visible star count
      const shouldApplyGravitationalEffects = visibleStars.length < 500 || 
                                              this.frameCount % this.gravitationalEffectsInterval === 0;

      for (const star of visibleStars) {
        let opacity = star.opacity;
        let fillStyle = '#fff'; // Default white color
        let twinkleSpeed = star.twinkleSpeed;

        // Apply gravitational lensing with throttling for performance
        let lensedPosition: { x: number; y: number };
        if (shouldApplyGravitationalEffects) {
          lensedPosition = this.applyMultipleGravitationalLensing(star);
          // Cache the result in the star object for reuse
          (star as any)._cachedLensedPosition = lensedPosition;
        } else {
          // Use cached position or fallback to original position
          lensedPosition = (star as any)._cachedLensedPosition || { x: star.x, y: star.y };
        }
        
        // Debug: Log if we're applying effects (reduced frequency)
        if ((this.explosionActive || this.logoBlackHoleActive) && star === this.stars[0]) {
          const timeDiff = performance.now() - (this.explosionActive ? this.explosionStartTime : this.logoBlackHoleStartTime);
          if (timeDiff % 500 < 16) { // Log every ~500ms
            console.log('📍 Effects active:', {
              original: { x: star.x, y: star.y },
              lensed: lensedPosition,
              explosionActive: this.explosionActive,
              blackHoleActive: this.logoBlackHoleActive,
              blackHoleCenter: this.logoBlackHoleCenter,
              timeDiff: Math.round(timeDiff),
              progress: this.logoBlackHoleActive ? Math.min(timeDiff / this.logoBlackHoleDuration, 1) : 0
            });
          }
        }

        // Calculate black hole visual effects if enabled and orbit exists
        if (this.config.blackHole.enabled && this.orbitContainer && this.orbitRect) {
          const gravityCoords = this.getGravityCoordinates();
          const dx = lensedPosition.x - gravityCoords.x;
          const dy = lensedPosition.y - gravityCoords.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxBlackHoleRadius = (gravityCoords.width / 2) * 0.8;

          if (distance <= maxBlackHoleRadius) {
            const influenceStrength = 1 - distance / maxBlackHoleRadius;
            const eventHorizonRadius =
              maxBlackHoleRadius * this.config.blackHole.eventHorizonRadius;

            // Redshift effect - stars become redder closer to the black hole
            if (distance <= eventHorizonRadius * 1.5) {
              const redshiftStrength = Math.min(influenceStrength * 0.7, 0.7);
              const red = Math.floor(255 * (1 - redshiftStrength * 0.3));
              const green = Math.floor(255 * (1 - redshiftStrength * 0.6));
              const blue = Math.floor(255 * (1 - redshiftStrength * 0.8));
              fillStyle = `rgb(${red}, ${green}, ${blue})`;
            }

            // Time dilation effect - slower twinkling near black hole
            if (twinkleSpeed !== null && distance <= eventHorizonRadius * 2) {
              const dilationFactor = 1 + influenceStrength * 2; // Up to 3x slower
              twinkleSpeed = star.twinkleSpeed! * dilationFactor;
            }
          }
        }

        // Apply twinkling with potentially modified speed
        if (twinkleSpeed !== null) {
          opacity = 0.5 + 0.5 * Math.sin(time / twinkleSpeed + star.twinklePhase);
        }

        ctx.fillStyle = fillStyle;
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(lensedPosition.x, lensedPosition.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw shooting stars
      ctx.globalAlpha = 1;
      for (const star of this.shootingStars) {
        if (!star.active || star.trail.length < 2) continue;

        // Draw curved trail using path history
        ctx.lineWidth = this.config.shootingStars.starHeight;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Draw smooth trail using quadratic curves
        if (star.trail.length >= 3) {
          // Start with a path for the entire trail
          const gradient = ctx.createLinearGradient(
            star.trail[0].x,
            star.trail[0].y,
            star.trail[star.trail.length - 1].x,
            star.trail[star.trail.length - 1].y
          );

          // Create gradient stops based on trail opacity
          for (let i = 0; i < star.trail.length; i++) {
            const stop = i / (star.trail.length - 1);
            const opacity = star.trail[i].opacity * star.opacity;
            gradient.addColorStop(
              stop,
              `rgba(${this.trailColors.r}, ${this.trailColors.g}, ${this.trailColors.b}, ${opacity * 0.6})`
            );
          }
          gradient.addColorStop(
            1,
            `rgba(${this.shootingStarColors.r}, ${this.shootingStarColors.g}, ${this.shootingStarColors.b}, ${star.opacity})`
          );

          ctx.strokeStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(star.trail[0].x, star.trail[0].y);

          // Draw smooth curves between points
          for (let i = 1; i < star.trail.length - 1; i++) {
            const currentPoint = star.trail[i];
            const nextPoint = star.trail[i + 1];

            // Calculate control point for smooth curve
            const controlX = currentPoint.x;
            const controlY = currentPoint.y;
            const endX = (currentPoint.x + nextPoint.x) / 2;
            const endY = (currentPoint.y + nextPoint.y) / 2;

            ctx.quadraticCurveTo(controlX, controlY, endX, endY);
          }

          // Draw to the final point
          const lastPoint = star.trail[star.trail.length - 1];
          ctx.lineTo(lastPoint.x, lastPoint.y);
          ctx.stroke();
        } else {
          // Fallback for short trails (less than 3 points)
          for (let i = 1; i < star.trail.length; i++) {
            const currentPoint = star.trail[i];
            const prevPoint = star.trail[i - 1];
            const segmentOpacity = currentPoint.opacity * star.opacity;

            const gradient = ctx.createLinearGradient(
              prevPoint.x,
              prevPoint.y,
              currentPoint.x,
              currentPoint.y
            );

            const startAlpha = i === 1 ? 0 : star.trail[i - 1].opacity * star.opacity;
            gradient.addColorStop(
              0,
              `rgba(${this.trailColors.r}, ${this.trailColors.g}, ${this.trailColors.b}, ${startAlpha})`
            );
            gradient.addColorStop(
              1,
              `rgba(${this.shootingStarColors.r}, ${this.shootingStarColors.g}, ${this.shootingStarColors.b}, ${segmentOpacity})`
            );

            ctx.strokeStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(currentPoint.x, currentPoint.y);
            ctx.stroke();
          }
        }

        // Draw bright head with glow
        const head = star.trail[star.trail.length - 1];
        const headRadius = this.config.shootingStars.starHeight;

        // Save context for glow effect
        ctx.save();

        // Draw glow layers (outer to inner)
        const glowLayers = [
          { radius: headRadius * 4, opacity: 0.1 },
          { radius: headRadius * 3, opacity: 0.2 },
          { radius: headRadius * 2, opacity: 0.4 },
          { radius: headRadius * 1.5, opacity: 0.6 },
        ];

        glowLayers.forEach((layer) => {
          ctx.fillStyle = `rgba(${this.shootingStarColors.r}, ${this.shootingStarColors.g}, ${this.shootingStarColors.b}, ${layer.opacity * star.opacity})`;
          ctx.beginPath();
          ctx.arc(head.x, head.y, layer.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw core with shadow glow
        ctx.shadowColor = `rgba(${this.shootingStarColors.r}, ${this.shootingStarColors.g}, ${this.shootingStarColors.b}, 0.8)`;
        ctx.shadowBlur = headRadius * 3;
        ctx.fillStyle = `rgba(${this.shootingStarColors.r}, ${this.shootingStarColors.g}, ${this.shootingStarColors.b}, ${star.opacity})`;
        ctx.beginPath();
        ctx.arc(head.x, head.y, headRadius, 0, Math.PI * 2);
        ctx.fill();

        // Restore context
        ctx.restore();
      }
    }

    private renderStatic(): void {
      if (!this.ctx) return;

      // Only fill background if color is set
      if (this.config.backgroundColor) {
        this.ctx.fillStyle = this.config.backgroundColor;
        this.ctx.fillRect(0, 0, this.width, this.height);
      } else {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }

      // Apply viewport culling to static render as well
      const padding = 50;
      const visibleStars = this.stars.filter(star => 
        star.x >= -padding && star.x <= this.width + padding &&
        star.y >= -padding && star.y <= this.height + padding
      );

      for (const star of visibleStars) {
        let fillStyle = '#fff'; // Default white color

        // Apply gravitational lensing to star position
        const lensedPosition = this.applyMultipleGravitationalLensing(star);

        // Calculate black hole visual effects if enabled and orbit exists
        if (this.config.blackHole.enabled && this.orbitContainer && this.orbitRect) {
          const gravityCoords = this.getGravityCoordinates();
          const dx = lensedPosition.x - gravityCoords.x;
          const dy = lensedPosition.y - gravityCoords.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxBlackHoleRadius = (gravityCoords.width / 2) * 0.8;

          if (distance <= maxBlackHoleRadius) {
            const influenceStrength = 1 - distance / maxBlackHoleRadius;
            const eventHorizonRadius =
              maxBlackHoleRadius * this.config.blackHole.eventHorizonRadius;

            // Redshift effect - stars become redder closer to the black hole
            if (distance <= eventHorizonRadius * 1.5) {
              const redshiftStrength = Math.min(influenceStrength * 0.7, 0.7);
              const red = Math.floor(255 * (1 - redshiftStrength * 0.3));
              const green = Math.floor(255 * (1 - redshiftStrength * 0.6));
              const blue = Math.floor(255 * (1 - redshiftStrength * 0.8));
              fillStyle = `rgb(${red}, ${green}, ${blue})`;
            }
          }
        }

        this.ctx.fillStyle = fillStyle;
        this.ctx.globalAlpha = star.opacity;
        this.ctx.beginPath();
        this.ctx.arc(lensedPosition.x, lensedPosition.y, star.radius, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    private updateLogoEffects(currentTime: number): void {
      // Check if explosion effect should end
      if (this.explosionActive && currentTime - this.explosionStartTime > this.explosionDuration) {
        console.log('🎆 Explosion effect ended');
        this.explosionActive = false;
      }

      // Check if black hole effect should end
      if (this.logoBlackHoleActive && currentTime - this.logoBlackHoleStartTime > this.logoBlackHoleDuration) {
        console.log('🌀 Black hole effect ended');
        this.logoBlackHoleActive = false;
        // Clear original stars array - the effect will naturally fade out
        this.originalStars = [];
        console.log('🌟 Black hole effect deactivated');
      }
    }

    private animateFrame(): void {
      const currentTime = performance.now();
      const deltaTime = Math.min(currentTime - this.lastTime, 16.67); // Cap at 60fps maximum
      this.lastTime = currentTime;

      // Update black hole rotation time
      this.blackHoleRotationTime += deltaTime;

      // Update logo effects timers
      this.updateLogoEffects(currentTime);

      // Throttle animation based on tab visibility and performance
      if (document.hidden || this.shouldThrottleAnimation()) {
        this.animationId = requestAnimationFrame(() => this.animateFrame());
        return;
      }

      this.updateShootingStars(deltaTime);
      this.render();

      this.animationId = requestAnimationFrame(() => this.animateFrame());
    }

    private shouldThrottleAnimation(): boolean {
      // Adaptive throttling based on performance metrics
      const isMobile = window.innerWidth <= 768;
      const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4;
      const visibleStarCount = this.stars.length;
      
      // Throttle more aggressively on mobile or low-end devices
      if (isMobile || isLowEnd) {
        // Throttle more when there are many stars
        if (visibleStarCount > 600) return Math.random() > 0.5; // Run 50% of frames
        return Math.random() > 0.7; // Run 70% of frames
      }
      
      // Throttle based on star count on all devices
      if (visibleStarCount > 1000) return Math.random() > 0.8; // Run 80% of frames
      
      // Throttle based on battery status
      if ('getBattery' in navigator) {
        interface BatteryManager {
          level: number;
          charging: boolean;
        }

        const getBattery = (navigator as { getBattery(): Promise<BatteryManager> }).getBattery;
        getBattery().then((battery: BatteryManager) => {
          if (battery.level < 0.2 && !battery.charging) return true; // Low battery and not charging
        });
      }

      return false;
    }

    private handleMobileViewportChange(): void {
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }

      // Use longer debounce for mobile to avoid UI bar changes
      this.resizeTimeout = window.setTimeout(() => {
        interface VisualViewport {
          width: number;
          height: number;
        }
        const visualViewport = window.visualViewport as VisualViewport;
        if (!visualViewport) return;

        const newWidth = visualViewport.width;
        const newHeight = visualViewport.height;

        // Only resize if width changed significantly or height changed more than 100px
        // This prevents recalculation when just browser UI appears/disappears
        const widthChange = Math.abs(newWidth - this.lastWidth);
        const heightChange = Math.abs(newHeight - this.lastHeight);

        if (widthChange > 50 || heightChange > 100) {
          this.performResize(newWidth, newHeight);
        }
      }, 300); // Longer debounce for mobile
    }

    private handleMobileResize(): void {
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }

      this.resizeTimeout = window.setTimeout(() => {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;

        // Store stable height on first load or significant width change
        if (this.stableHeight === 0 || Math.abs(newWidth - this.lastWidth) > 50) {
          this.stableHeight = newHeight;
        }

        // Only resize if width changed significantly or height is much larger than stable height
        // This prevents recalculation when browser UI appears/disappears
        const widthChange = Math.abs(newWidth - this.lastWidth);
        const heightFromStable = Math.abs(newHeight - this.stableHeight);

        if (widthChange > 50 || heightFromStable < 100) {
          // Use stable height for better mobile experience
          this.performResize(newWidth, Math.max(newHeight, this.stableHeight));
        }
      }, 300); // Longer debounce for mobile
    }

    private performResize(newWidth?: number, newHeight?: number): void {
      const oldWidth = this.width;
      const oldHeight = this.height;

      // Update dimensions if provided, otherwise recalculate
      if (newWidth !== undefined && newHeight !== undefined) {
        this.width = newWidth;
        this.height = newHeight;
        this.lastWidth = newWidth;
        this.lastHeight = newHeight;

        // Update canvas
        this.dpr = Math.min(window.devicePixelRatio || 1, 2);
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;

        if (this.ctx) {
          this.ctx.scale(this.dpr, this.dpr);
          this.ctx.fillStyle = '#000';
          this.ctx.fillRect(0, 0, this.width, this.height);
        }
      } else {
        this.setupCanvas();
      }

      // Update orbit container position after resize
      this.findOrbitContainer();

      // Calculate correct number of stars for new canvas size
      const area = this.width * this.height;
      const targetStarCount = Math.floor(area * this.config.stars.starDensity);
      const currentStarCount = this.stars.length;

      if (targetStarCount !== currentStarCount) {
        // Recalculate stars to maintain consistent density
        this.initializeStars();
      } else {
        // Use smart scaling: check if cached data is available for better scaling
        const cachedData = StarFieldCacheManager.loadCache();

        if (cachedData && this.isConfigCompatible(cachedData.baseConfig)) {
          // Use normalized coordinates for perfect scaling
          console.log('🔄 Rescaling stars using cached normalized coordinates');
          this.stars = cachedData.stars.map((cachedStar) => ({
            x: cachedStar.normalizedX * this.width,
            y: cachedStar.normalizedY * this.height,
            radius: cachedStar.radius,
            opacity: cachedStar.opacity,
            twinkleSpeed: cachedStar.twinkleSpeed,
            twinklePhase: cachedStar.twinklePhase,
          }));
        } else {
          // Fallback: proportional scaling
          const widthRatio = this.width / oldWidth;
          const heightRatio = this.height / oldHeight;

          for (const star of this.stars) {
            star.x *= widthRatio;
            star.y *= heightRatio;
          }
        }
      }
    }

    private handleResize(): void {
      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
      }

      this.resizeTimeout = window.setTimeout(() => {
        this.performResize();
      }, 150);
    }

    disconnectedCallback(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }

      if (this.resizeTimeout) {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = null;
      }

      // Clean up event listeners
      if (this.isMobile) {
        if ('visualViewport' in window && window.visualViewport) {
          interface VisualViewport extends EventTarget {
            removeEventListener(type: string, listener: EventListener): void;
          }
          const visualViewport = window.visualViewport as VisualViewport;
          visualViewport.removeEventListener('resize', this.handleMobileViewportChange.bind(this));
        } else {
          window.removeEventListener('resize', this.handleMobileResize.bind(this));
        }
      } else {
        window.removeEventListener('resize', this.handleResize.bind(this));
      }

      window.removeEventListener('mousemove', this.handleMouseMove);
      if (this.canvas) {
        this.canvas.removeEventListener('mouseleave', this.handleMouseLeave);
      }

      // Clean up logo effect listeners
      window.removeEventListener('starFieldDistort', this.handleStarFieldDistort);
      window.removeEventListener('blackHoleActivated', this.handleBlackHoleActivated);
    }

    private handleMouseMove = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouseX = event.clientX - rect.left;
      this.mouseY = event.clientY - rect.top;
    };

    private handleMouseLeave = () => {
      // Move mouse "gravity" off-screen when mouse leaves
      this.mouseX = -1000;
      this.mouseY = -1000;
    };

    private handleStarFieldDistort = () => {
      // Trigger explosion effect
      console.log('🎆 Explosion effect triggered!');
      this.explosionActive = true;
      this.explosionStartTime = performance.now();
    };

    private handleBlackHoleActivated = (event: Event) => {
      const customEvent = event as CustomEvent;
      const { centerX, centerY } = customEvent.detail;
      
      console.log('🌀 Black hole effect triggered!', { centerX, centerY });
      
      // Convert screen coordinates to canvas coordinates
      const canvasRect = this.canvas.getBoundingClientRect();
      const canvasX = centerX - canvasRect.left;
      const canvasY = centerY - canvasRect.top;
      
      console.log('🌀 Black hole canvas position:', { canvasX, canvasY });
      
      // Store original star positions before sucking them in
      this.originalStars = this.stars.map(star => ({
        x: star.x,
        y: star.y,
        radius: star.radius,
        opacity: star.opacity,
        twinkleSpeed: star.twinkleSpeed,
        twinklePhase: star.twinklePhase
      }));
      
      // Activate black hole effect
      this.logoBlackHoleActive = true;
      this.logoBlackHoleStartTime = performance.now();
      this.logoBlackHoleCenter = { x: canvasX, y: canvasY };
    };
  }

  // Define the custom element
  if (!customElements.get('space-background')) {
    customElements.define('space-background', SpaceBackground);
  }
</script>

<style>
  space-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* Use stable viewport height on mobile to avoid browser UI changes */
    height: 100svh; /* Small viewport height - excludes dynamic UI */
    min-height: 100vh; /* Fallback for older browsers */
    z-index: -1;
    overflow: hidden;
    pointer-events: none;
    contain: layout style paint;
    will-change: auto;
    content-visibility: auto;
    transform: translateZ(0); /* Force GPU acceleration */
  }

  /* Mobile optimizations */
  @media (max-width: 768px) {
    space-background {
      /* Use the largest possible viewport to avoid recalculation */
      height: 100lvh; /* Large viewport height - includes dynamic UI */
      min-height: 100dvh; /* Dynamic viewport height as fallback */
    }
  }

  .space-canvas {
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    backface-visibility: hidden;
    perspective: 1000px;
    transform: translate3d(0, 0, 0); /* Force GPU layer */
  }
</style>
